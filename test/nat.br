module Nat

import Prelude

data Nat
| zero : Nat
| succ : Nat -o Nat

def nat_rec (0 P : Nat -> Type)(pz : P zero)(ps : Pi n : Nat, P n -> P (succ n))(n : Nat): P n =
  match n return P with
  | zero -> pz
  | succ m -> ps m (nat_rec P pz ps m)

def no_conf_t(n m : Nat): Type =
  match n with
  | zero -> (match m with
    | zero -> Unit
    | succ _ -> Bottom)
  | succ n -> (match m with
    | zero -> Bottom
    | succ m -> Id Nat n m)

def no_conf(n m : Nat)(e : Id Nat n m): no_conf_t n m =
  let no_conf_h (n : Nat): no_conf_t n n =
    match n return fun (n : Nat) -> no_conf_t n n with
    | zero -> tt
    | succ n -> refl Nat n
  in e (fun k -> no_conf_t n k) (no_conf_h n)

def even (n : Nat) : Bool =
  match n with
  | zero -> true
  | succ n -> odd n
and odd (n : Nat): Bool =
  match n with
  | zero -> false
  | succ n -> even n

def plus (n m : Nat): Nat = 
  match n with
  | zero -> m
  | succ n -> succ (plus n m)

def plus_zero(n : Nat): Id Nat n (plus n zero) =
  match n return fun (n : Nat) -> Id Nat n (plus n zero) with
  | zero -> refl Nat zero
  | succ n -> let ih = plus_zero n in cong Nat Nat n (plus n zero) succ ih

def plus_succ (n m : Nat): Id Nat (succ (plus m n)) (plus m (succ n)) =
  match m return fun (m : Nat) -> Id Nat (succ (plus m n)) (plus m (succ n)) with
  | zero -> refl Nat (succ n)
  | succ m -> let ih = plus_succ n m in cong Nat Nat (succ (plus m n)) (plus m (succ n)) succ ih

def plus_commutes(n m : Nat): Id Nat (plus n m) (plus m n) =
  match n return fun (n : Nat) -> Id Nat (plus n m) (plus m n) with
  | zero -> plus_zero m
  | succ n ->
    let ih = plus_commutes n m in 
    let ps = plus_succ n m in
      ps (fun k -> Id Nat (succ (plus n m)) k) (cong Nat Nat (plus n m) (plus m n) succ ih)

def plus_associates: Pi (n m o: Nat), Id Nat (plus n (plus m o)) (plus (plus n m) o) =
  fun n -> match n return fun (n : Nat) -> Pi (m o : Nat),Id Nat (plus n (plus m o)) (plus (plus n m) o) with
  | zero -> fun m o -> refl Nat (plus m o)
  | succ n -> fun m o ->
	let ih = plus_associates n m o in
      cong Nat Nat (plus n (plus m o)) (plus (plus n m) o) succ ih

def mult(n m : Nat): Nat =
  match n with
  | zero -> zero
  | succ n -> plus m (mult n m)

def eq (n m : Nat): Bool =
  match n with
  | zero -> (match m with
    | zero -> true
    | succ m -> false)
  | succ n -> (match m with
    | zero -> false
    | succ m -> eq n m)

def NatEq (n m : Nat): Type = lift (eq n m)

def NatRefl: Pi n : Nat, NatEq n n =
  nat_rec (fun n -> NatEq n n) tt (fun _ ih -> ih)

(* Id Nat <-> NatEq *)
def dec_eq(n m : Nat): NatEq n m => Id Nat n m =
  match n return fun (n : Nat) -> NatEq n m => Id Nat n m with
  | zero -> (match m return fun (y : Nat) -> NatEq zero y => Id Nat zero y with
    | zero -> fun _ -> refl Nat zero
    | succ m -> fun p -> (match0 p with))
  | succ n -> (match m return fun (y : Nat) -> NatEq (succ n) y => Id Nat (succ n) y with
    | zero -> fun p -> (match0 p with)
    | succ m -> fun p -> cong Nat Nat n m succ (dec_eq n m p))

def dec_eq_inv(n m : Nat): Id Nat n m -> NatEq n m =
  fun eq -> eq (fun k -> NatEq n k) (NatRefl n)

def nat_uip(n m : Nat): Pi 0 x : NatEq n m, Pi 0 y : NatEq n m, Id (NatEq n m) x y =
  match n return fun (i : Nat) -> Pi 0 x : NatEq i m, Pi 0 y : NatEq i m, Id (NatEq i m) x y with
  | zero -> (match m return fun (j : Nat) -> Pi 0 x : NatEq zero j, Pi 0 y : NatEq zero j, Id (NatEq zero j) x y with
    | zero -> Unit_equal
    | succ m -> fun x _ -> (match0 x with))
  | succ n -> (match m return fun (j : Nat)  -> Pi 0 x : NatEq (succ n) j, Pi 0 y : NatEq (succ n) j, Id (NatEq (succ n) j) x y with
    | zero -> fun x _ -> (match0 x with)
    | succ m -> nat_uip n m)

(* Nat is accessible *)

def Less(n m : Nat): Type =
  match m with
  | zero -> Bottom
  | succ m ->
    match n with
    | zero -> Unit
    | succ n -> Less n m

def Leq (n m : Nat): Type = Less n (succ m)

def less_than_zero : Pi n : Nat, Less n zero -> Bottom =
  nat_rec (fun n -> Less n zero -> Bottom) (fun x -> x) (fun _ _ x -> x)

def less_than_succ : Pi n : Nat, Less n (succ n) =
  nat_rec (fun (n : Nat) -> Less n (succ n)) tt (fun _ ih -> ih)

def leq_is_less_or_eq : Pi (n m : Nat), Leq n m -> Either (Less n m) (Id Nat n m) =
  nat_rec
    (fun z -> Pi m : Nat, Leq z m -> Either (Less z m)(Id Nat z m))
    (nat_rec
      (fun z -> Leq zero z -> Either (Less zero z) (Id Nat zero z))
      (fun _ -> right (Less zero zero) (Id Nat zero zero) (refl Nat zero))
      (fun z _ _ -> left (Less zero (succ z)) (Id Nat zero (succ z)) tt))
    (fun y ih -> nat_rec
      (fun z -> Leq (succ y) z -> Either (Less (succ y) z) (Id Nat (succ y) z))
      (fun l -> less_than_zero y l (Either (Less (succ y) zero) (Id Nat (succ y) zero)))
      (fun z _ l ->
        match ih z l with
        | left l -> left (Less y z) (Id Nat (succ y) (succ z)) l
        | right e -> right (Less y z) (Id Nat (succ y) (succ z)) (cong Nat Nat y z succ e)))

def strong (p : Nat -> Type)(h : Pi x : Nat, (Pi y : Nat, Less y x -> p y) -> p x): Pi (n m : Nat), Less m n -> p m =
  nat_rec
    (fun z -> Pi m : Nat, Less m z -> p m)
    (fun m l -> less_than_zero m l (p m))
    (fun n ih m l -> match leq_is_less_or_eq m n l with
      | left l -> ih m l
      | right e -> sym Nat m n e p (h n ih))

def strong_induction (p : Nat -> Type)(h : Pi x : Nat, (Pi y : Nat, Less y x -> p y) -> p x)(n : Nat): p n =
  strong p h (succ n) n (less_than_succ n)

def nat_wf (n : Nat): Acc Nat Less n =
  strong_induction (Acc Nat Less) (mk Nat Less) n