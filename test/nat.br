module Nat

import Prelude

data Nat
| zero : Nat
| succ : Nat -o Nat

def nat_rec (0 P : Nat -> Type)(pz : P zero)(ps : Pi n : Nat, P n -> P (succ n))(n : Nat): P n =
  match n return P with
  | zero -> pz
  | succ m -> ps m (nat_rec P pz ps m)

def no_conf_t(n m : Nat): Type =
  match n with
  | zero -> (match m with
    | zero -> Unit
    | succ _ -> Bottom)
  | succ n -> (match m with
    | zero -> Bottom
    | succ m -> Id Nat n m)

def no_conf(n m : Nat)(e : Id Nat n m): no_conf_t n m =
  let no_conf_h (n : Nat): no_conf_t n n =
    match n return fun (n : Nat) -> no_conf_t n n with
    | zero -> tt
    | succ n -> refl Nat n
  in e (fun k -> no_conf_t n k) (no_conf_h n)

def even (n : Nat) : Bool =
  match n with
  | zero -> true
  | succ n -> odd n
and odd (n : Nat): Bool =
  match n with
  | zero -> false
  | succ n -> even n

def plus (n m : Nat): Nat = 
  match n with
  | zero -> m
  | succ n -> succ (plus n m)

def plus_zero(n : Nat): Id Nat n (plus n zero) =
  match n return fun (n : Nat) -> Id Nat n (plus n zero) with
  | zero -> refl Nat zero
  | succ n -> let ih = plus_zero n in cong Nat Nat n (plus n zero) succ ih

def plus_succ (n m : Nat): Id Nat (succ (plus m n)) (plus m (succ n)) =
  match m return fun (m : Nat) -> Id Nat (succ (plus m n)) (plus m (succ n)) with
  | zero -> refl Nat (succ n)
  | succ m -> let ih = plus_succ n m in cong Nat Nat (succ (plus m n)) (plus m (succ n)) succ ih

def plus_commutes(n m : Nat): Id Nat (plus n m) (plus m n) =
  match n return fun (n : Nat) -> Id Nat (plus n m) (plus m n) with
  | zero -> plus_zero m
  | succ n ->
    let ih = plus_commutes n m in 
    let ps = plus_succ n m in
      ps (fun k -> Id Nat (succ (plus n m)) k) (cong Nat Nat (plus n m) (plus m n) succ ih)

def plus_associates: Pi (n m o: Nat), Id Nat (plus n (plus m o)) (plus (plus n m) o) =
  fun n -> match n return fun (n : Nat) -> Pi (m o : Nat),Id Nat (plus n (plus m o)) (plus (plus n m) o) with
  | zero -> fun m o -> refl Nat (plus m o)
  | succ n -> fun m o ->
	let ih = plus_associates n m o in
      cong Nat Nat (plus n (plus m o)) (plus (plus n m) o) succ ih

def mult(n m : Nat): Nat =
  match n with
  | zero -> zero
  | succ n -> plus m (mult n m)

def eq (n m : Nat): Bool =
  match n with
  | zero -> (match m with
    | zero -> true
    | succ m -> false)
  | succ n -> (match m with
    | zero -> false
    | succ m -> eq n m)

def NatEq (n m : Nat): Type = lift (eq n m)

def NatRefl: Pi n : Nat, NatEq n n =
  nat_rec (fun n -> NatEq n n) tt (fun _ ih -> ih)

(* Id Nat <-> NatEq *)
def dec_eq(n m : Nat): NatEq n m => Id Nat n m =
  match n return fun (n : Nat) -> NatEq n m => Id Nat n m with
  | zero -> (match m return fun (y : Nat) -> NatEq zero y => Id Nat zero y with
    | zero -> fun _ -> refl Nat zero
    | succ m -> fun p -> (match0 p with))
  | succ n -> (match m return fun (y : Nat) -> NatEq (succ n) y => Id Nat (succ n) y with
    | zero -> fun p -> (match0 p with)
    | succ m -> fun p -> cong Nat Nat n m succ (dec_eq n m p))

def dec_eq_inv(n m : Nat): Id Nat n m -> NatEq n m =
  fun eq -> eq (fun k -> NatEq n k) (NatRefl n)

def nat_uip(n m : Nat): Pi 0 x : NatEq n m, Pi 0 y : NatEq n m, Id (NatEq n m) x y =
  match n return fun (i : Nat) -> Pi 0 x : NatEq i m, Pi 0 y : NatEq i m, Id (NatEq i m) x y with
  | zero -> (match m return fun (j : Nat) -> Pi 0 x : NatEq zero j, Pi 0 y : NatEq zero j, Id (NatEq zero j) x y with
    | zero -> Unit_equal
    | succ m -> fun x _ -> (match0 x with))
  | succ n -> (match m return fun (j : Nat)  -> Pi 0 x : NatEq (succ n) j, Pi 0 y : NatEq (succ n) j, Id (NatEq (succ n) j) x y with
    | zero -> fun x _ -> (match0 x with)
    | succ m -> nat_uip n m)

(* Nat is accessible *)

def Less(n m : Nat): Type =
  match m with
  | zero -> Bottom
  | succ m ->
    match n with
    | zero -> Unit
    | succ n -> Less n m

def Leq (n m : Nat): Type = Less n (succ m)

def less_than_zero : Pi n : Nat, Less n zero => Bottom =
  nat_rec (fun n -> Less n zero => Bottom)
    (fun x -> match0 x Void with)
    (fun _ _ x -> match0 x Void with)

def less_than_succ : Pi n : Nat, Less n (succ n) =
  nat_rec (fun (n : Nat) -> Less n (succ n)) tt (fun _ ih -> ih)

def leq_is_less_or_eq : Pi (n m : Nat), Leq n m -> Either (Less n m) (Id Nat n m) =
  nat_rec
    (fun z -> Pi m : Nat, Leq z m -> Either (Less z m)(Id Nat z m))
    (nat_rec
      (fun z -> Leq zero z -> Either (Less zero z) (Id Nat zero z))
      (fun _ -> right (Less zero zero) (Id Nat zero zero) (refl Nat zero))
      (fun z _ _ -> left (Less zero (succ z)) (Id Nat zero (succ z)) tt))
    (fun y ih -> nat_rec
      (fun z -> Leq (succ y) z -> Either (Less (succ y) z) (Id Nat (succ y) z))
      (fun l -> less_than_zero y l (Either (Less (succ y) zero) (Id Nat (succ y) zero)))
      (fun z _ l ->
        match ih z l with
        | left l -> left (Less y z) (Id Nat (succ y) (succ z)) l
        | right e -> right (Less y z) (Id Nat (succ y) (succ z)) (cong Nat Nat y z succ e)))

def trans : Pi (j m k : Nat), Less j m -> Less m (succ k) -> Less j k =
  nat_rec (fun j -> Pi (m k : Nat), Less j m -> Less m (succ k) -> Less j k)
    (nat_rec (fun m -> Pi (k : Nat), Less zero m -> Less m (succ k) -> Less zero k)
      (fun k l1 _ -> less_than_zero zero l1 (Less zero k))
      (fun m ih -> nat_rec (fun k -> Less zero (succ m) -> Less (succ m) (succ k) -> Less zero k)
    	(fun l1 l2 -> less_than_zero m l2 (Less zero zero))
    	(fun k _ l1 l2 -> tt)))
    (fun j ih -> nat_rec (fun m -> Pi k : Nat, Less (succ j) m -> Less m (succ k) -> Less (succ j) k)
      (fun k l1 l2 -> less_than_zero (succ j) l1 (Less (succ j) k))
      (fun m _ -> nat_rec (fun k -> Less (succ j) (succ m) -> Less (succ m) (succ k) -> Less (succ j) k)
      	(fun l1 l2 -> less_than_zero m l2 (Less (succ j) zero))
      	(fun k _ l1 l2 -> ih m k l1 l2)))

def strong(p : Nat -> Type)(h : Pi 0 x : Nat, (Pi 0 y : Nat, Less y x => p y) -> p x): Pi (n : Nat)(0 m : Nat), Less m n => p m =
  nat_rec (fun n -> Pi 0 m : Nat, Less m n => p m)
    (fun m l -> match0 less_than_zero m l Void with)
    (fun k ih m l1 -> h m (fun j l2 -> ih j (Nat.trans j m k l2 l1)))

def strong_induction(p : Nat -> Type)(h : Pi 0 x : Nat, (Pi 0 y : Nat, Less y x => p y) -> p x)(n : Nat): p n =
  strong p h (succ n) n (less_than_succ n)

def nat_wf(n : Nat): Acc Nat Less n =
  strong_induction (Acc Nat Less) (Prelude.Acc.mk Nat Less) n

def nat_case(P : Nat -> Type)(pz : P zero)(ps : Pi 1 m : Nat, P (succ m))(1 n : Nat): P n =
  match1 n return P with
  | zero -> pz
  | succ n -> ps n

def nat_fold(P : Nat -> Type)(pz : P zero)(ps : Pi 0 m : Nat, P m -o P (succ m))(1 n : Nat)(acn : Acc Nat Less n): P n =
  wf_rec Nat Less (fun m -> Pi 1 n : Nat, Id Nat n m -> P m)
    (fun x f ->
      nat_case (fun n -> Id Nat n x -> P x)
    	(fun e -> e P pz)
    	(fun m e -> e P (ps m (f m (e (fun k -> Less m k) (less_than_succ m)) m (refl Nat m)))))
    n acn n (refl Nat n)
    
  
